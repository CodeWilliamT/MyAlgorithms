using namespace std;
#include <iostream>
#include <vector>
//找规律，动态规划，难点在找规律上
//由于逆序数的产生是大数向前导致的，所以可以从前往后推导
//递推找规律：
//因为第 n 个数（即 n）肯定比前 n-1 个数大，所以，我们可以把数字 n 插入到 0~n-1 的不同位置：
//假如前 n - 1 个数的数组中正好有 k 个逆序对，那么，我们可以把 n 插入到这个数组的最后一位，得到的新数组正好也是 k 个逆序对，
//因为，新插入的 n 不会与任何数字组成逆序对，而原来数组中的逆序对保持不变；
//假如前 n - 1 个数的数组中正好有 k - 1 个逆序对，那么，我们可以把 n 插入到这个数组的倒数第二位，这样，我们会得到 1 个新的逆序对
//即原数组的最后一位与 n 组成的逆序对，而原来数组中的 k - 1 个逆序对保持不变，总共会有 k 个逆序对；
//假如前 n - 1 个数的数组中正好有 k - 2 个逆序对，那么，我们可以把 n 插入到这个数组的倒数第三位，这样，我们会得到 2 个新的逆序对
//即原数组的最后两位与 n 组成的逆序对，而原来数组中的 k - 2 个逆序对保持不变，总共会有 k 个逆序对；
//...
//假如前 n - 1 个数的数组中正好有 0(k - k) 个逆序对，那么，我们可以把 n 插入到这个数组的倒数第 k + 1 位，这样，我们会得到 k 个新的逆序对
//即原数组的最后 k 位与 n 组成的逆序对，而原来数组中的 0 个逆序对保持不变，总共会有 k 个逆序对；
//然后需排除j大于等i的时候，因为无法前移
//所以可得状态转移方程。
//状态量：f[i][j] i以内有j个逆序数的排列有多少种。
//状态转移方程:f[i][j] = f[i - 1][j]+f[i][j-1]-j>=i?f[i-1][j-i];j <= min(k, i * (i - 1) / 2)
//边界:f[1][0]=1;
class Solution {
public:
    int kInversePairs(int n, int k) {
        long long f[1001][1001]{};
        f[1][0]=1;
        for (int i = 2; i <= n; i++) {
            f[i][0] = 1;
            for (int j = 1; j <= min(k, i * (i - 1) / 2); j++)
            {
                f[i][j] = f[i - 1][j]+f[i][j-1];
                if (j >= i)f[i][j] -= f[i - 1][j - i];
                f[i][j] = (f[i][j]+ 1000000007)%1000000007;

            }
        }
        return f[n][k];
    }
};